# HG changeset patch
# User Joe Walker <jwalker@mozilla.com>
# Date 1306500542 -3600
# Node ID 5461e667a7350ce8040d8ad4b7a296a2a68bee53
# Parent ca58b6fe3ef4b7f32a270559e311695e2aa58a51
Bug 656666 - Update HudService.jsm to allow GCLI integration

diff --git a/browser/devtools/webconsole/Commands.jsm b/browser/devtools/webconsole/Commands.jsm
new file mode 100644
--- /dev/null
+++ b/browser/devtools/webconsole/Commands.jsm
@@ -0,0 +1,888 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is GCLI Commands.
+ *
+ * The Initial Developer of the Original Code is
+ * The Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2011
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Joe Walker <jwalker@mozilla.com> (original author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+
+let EXPORTED_SYMBOLS = [];
+
+Components.utils.import("resource:///modules/gcli.jsm");
+Components.utils.import("resource://gre/modules/XPCOMUtils.jsm");
+Components.utils.import("resource://gre/modules/Services.jsm");
+
+XPCOMUtils.defineLazyGetter(this, "stringBundle", function () {
+  return Services.strings.createBundle("chrome://browser/locale/gcli.properties");
+});
+
+/**
+ * Lookup a string in the GCLI string bundle
+ * @param aName The name to lookup
+ * @return The looked up name
+ */
+function lookup(aName)
+{
+  try {
+    return stringBundle.GetStringFromName(aName);
+  } catch (ex) {
+    Services.console.logStringMessage("Failure in lookup('" + aName + "')");
+    throw new Error("Failure in lookup('" + aName + "')");
+  }
+};
+
+/**
+ * Lookup a string in the GCLI string bundle
+ * @param aName The name to lookup
+ * @param aSwaps An array of swaps. See stringBundle.formatStringFromName
+ * @return The looked up name
+ */
+function lookupFormat(aName, aSwaps)
+{
+  try {
+    return stringBundle.formatStringFromName(aName, aSwaps, aSwaps.length);
+  } catch (ex) {
+    Services.console.logStringMessage("Failure in lookupFormat('" + aName + "')");
+    throw new Error("Failure in lookupFormat('" + aName + "')");
+  }
+}
+
+let util = gcli._internal.require("gcli/util");
+let dom = gcli._internal.require("gcli/util").dom;
+
+let gcli = gcli._internal.require("gcli/index");
+
+let Argument = gcli._internal.require("gcli/argument").Argument;
+
+let types = gcli._internal.require("gcli/types");
+let Conversion = gcli._internal.require("gcli/types").Conversion;
+let Type = gcli._internal.require("gcli/types").Type;
+let SelectionType = gcli._internal.require("gcli/types").SelectionType;
+let Status = gcli._internal.require("gcli/types").Status;
+
+let field = gcli._internal.require("gcli/ui/field");
+let Field = gcli._internal.require("gcli/ui/field").Field;
+
+let canon = gcli._internal.require("gcli/canon");
+
+
+/**
+ * Utility to create a link to a bug number
+ */
+function getBugLink(bugid)
+{
+  return '<br/>To comment on this command, use <a target="_blank" ' +
+      'href="https://bugzilla.mozilla.org/show_bug.cgi?id=' + bugid + '">' +
+      "bug " + bugid + "</a>.";
+}
+
+
+/**
+ * A type for the resources in the current page
+ */
+function ResourceType(typeSpec)
+{
+  if (typeSpec != null) {
+    throw new Error("ResourceType can not be customized");
+  }
+}
+
+ResourceType.prototype = Object.create(types.SelectionType.prototype);
+
+ResourceType.prototype.lookup = function()
+{
+  let reply = [];
+  let sheets = Array.prototype.slice.call(document.styleSheets);
+  for (let i = 0; i < sheets.length; i++) {
+    let sheet = sheets[i];
+    // When we're in chrome, replace style#i with style#Ln where n is the line
+    // number of the style element in the HTML document.
+    reply.push({
+      name: sheet.href || "style#" + i,
+      value: sheet
+    });
+  }
+  reply.push({
+    name: "page",
+    value: window.document
+  });
+  // There are other page resources that we need to include here too
+  return reply;
+};
+
+ResourceType.prototype.name = "resource";
+
+types.registerType(ResourceType);
+
+
+/**
+ * A CSS expression that refers to a single node
+ */
+function NodeType(typeSpec)
+{
+  if (typeSpec != null) {
+    throw new Error("NodeType can not be customized");
+  }
+}
+
+NodeType.prototype = Object.create(Type.prototype);
+
+NodeType.prototype.stringify = function(value)
+{
+  return value.__gcliQuery || "Error";
+};
+
+NodeType.prototype.parse = function(arg)
+{
+  if (arg.text === "") {
+    return new Conversion(null, arg, Status.INCOMPLETE, "No matches");
+  }
+
+  let nodes;
+  try {
+    nodes = document.querySelectorAll(arg.text);
+  }
+  catch (ex) {
+    return new Conversion(null, arg, Status.ERROR, lookup("nodeParseSyntax"));
+  }
+
+  if (nodes.length === 0) {
+    return new Conversion(null, arg, Status.INCOMPLETE, "No matches");
+  }
+
+  if (nodes.length === 1) {
+    let node = nodes.item(0);
+    node.__gcliQuery = arg.text;
+    return new Conversion(node, arg, Status.VALID, "");
+  }
+
+  return new Conversion(null, arg, Status.ERROR,
+      "Too many matches (" + nodes.length + ")");
+};
+
+NodeType.prototype.name = "node";
+
+types.registerType(NodeType);
+
+
+/**
+ * 'file' allows upload of a file
+ */
+function FileType(typeSpec)
+{
+  if (typeSpec != null) {
+    throw new Error("FileType can not be customized");
+  }
+}
+
+FileType.prototype = Object.create(Type.prototype);
+
+FileType.prototype.stringify = function(value)
+{
+  if (value == null) {
+    return "";
+  }
+  return value.toString();
+};
+
+FileType.prototype.parse = function(arg)
+{
+  if (arg.text == null || arg.text === "") {
+    return new Conversion(null, arg, Status.INCOMPLETE, "");
+  }
+  return new Conversion(arg.text, arg);
+};
+
+FileType.prototype.name = "file";
+
+types.registerType(FileType);
+
+
+/**
+ * A field that allows editing of strings
+ */
+function FileField(type, options)
+{
+  this.doc = options.document;
+  this.type = type;
+  this.arg = new Argument();
+
+  this.element = dom.createElement("input", null, this.doc);
+  this.element.type = "file";
+
+  this.onInputChange = this.onInputChange.bind(this);
+  this.element.addEventListener("keyup", this.onInputChange, false);
+
+  this.fieldChanged = util.createEvent("FileField.fieldChanged");
+}
+
+FileField.prototype = Object.create(Field.prototype);
+
+FileField.prototype.destroy = function()
+{
+  this.element.removeEventListener("keyup", this.onKeyup, false);
+};
+
+FileField.prototype.setConversion = function(conversion)
+{
+  this.arg = conversion.arg;
+  this.element.value = conversion.arg.text;
+  this.setMessage(conversion.message);
+};
+
+FileField.prototype.getConversion = function()
+{
+  // This tweaks the prefix/suffix of the argument to fit
+  this.arg = this.arg.beget(this.element.value, { prefixSpace: true });
+  return this.type.parse(this.arg);
+};
+
+FileField.claim = function(type)
+{
+  return type instanceof FileType ? Field.MATCH : Field.IF_NOTHING_BETTER;
+};
+
+field.addField(FileField);
+
+
+/**
+ * 'echo' command
+ */
+gcli.addCommand({
+  name: "echo",
+  description: "Show a message",
+  params: [
+    { name: "message", type: "string", description: "Message to output" }
+  ],
+  returnType: "string",
+  exec: function(args, env) {
+    return args.message;
+  }
+});
+
+
+/**
+ * 'help' command
+ */
+gcli.addCommand({
+  name: "help",
+  returnType: "html",
+  description: "Get help on the available commands",
+  exec: function(args, context) {
+    let output = [];
+
+    output.push("<strong>Available Commands:</strong><br/>");
+
+    let commandNames = canon.getCommandNames();
+    commandNames.sort();
+
+    output.push("<table>");
+    for (let i = 0; i < commandNames.length; i++) {
+      let command = canon.getCommand(commandNames[i]);
+      if (!command.hidden && command.description) {
+        output.push("<tr>");
+        output.push('<th class="gcliCmdHelpRight">' + command.name + "</th>");
+        output.push("<td>&#x2192; " + command.description + "</td>");
+        output.push("</tr>");
+      }
+    }
+    output.push("</table>");
+
+    return output.join("");
+  }
+});
+
+
+/**
+ * 'version' command.
+ */
+gcli.addCommand({
+  name: "version",
+  description: "Show current FF version number",
+  returnType: "string",
+  exec: function(args, env) {
+    return "You are running Firefox version 9.0a1 (2011-08-18)";
+  }
+});
+
+
+/**
+ * 'edit' command
+ */
+gcli.addCommand({
+  name: "edit",
+  description: lookup("editDesc"),
+  manual: lookup("editManual"),
+  params: [
+     {
+       name: "resource",
+       type: "resource",
+       description: lookup("editResourceDesc")
+     }
+   ],
+   returnType: "html",
+   exec: function(args, context) {
+     let element = args.resource.documentElement || args.resource.ownerNode;
+     return '<textarea rows=5 cols=80 style="font-family:monospace">' +
+         lookup("editPretend") + ":\n" +
+         element.innerHTML.substring(0, 500) + "...</textarea>" +
+         getBugLink(683499);
+   }
+});
+
+
+/**
+ * 'stylizer' command
+ */
+gcli.addCommand({
+  name: "stylizer",
+  description: lookup("stylizerDesc"),
+  manual: lookup("stylizerManual"),
+  params: [
+     {
+       name: "node",
+       type: "node",
+       description: lookup("stylizerNodeDesc"),
+     }
+   ],
+   returnType: "html",
+   exec: function(args, context) {
+     return lookupFormat("stylizerReply", [ "" + args.node ]) +
+         getBugLink(683502);
+   }
+});
+
+
+let breakpoints = [];
+
+/**
+ * 'break' command
+ */
+gcli.addCommand({
+  name: "break",
+  description: lookup("breakDesc"),
+  manual: lookup("breakManual")
+});
+
+
+/**
+ * 'break list' command
+ */
+gcli.addCommand({
+  name: "break list",
+  description: lookup("breaklistDesc"),
+  returnType: "html",
+  exec: function(args, context) {
+    if (breakpoints.length === 0) {
+      return lookup("breaklistNone") + getBugLink(683503);
+    }
+
+    let reply = lookup("breaklistIntro");
+    reply += "<ol>";
+    breakpoints.forEach(function(breakpoint) {
+      reply += "<li>" + JSON.stringify(breakpoint) + "</li>";
+    });
+    reply += "</ol>";
+    return reply + getBugLink(683503);
+  }
+});
+
+
+/**
+ * 'break add' command
+ */
+gcli.addCommand({
+  name: "break add",
+  description: lookup("breakaddDesc"),
+  manual: lookup("breakaddManual")
+});
+
+
+/**
+ * 'break add line' command
+ */
+gcli.addCommand({
+  name: "break add line",
+  description: lookup("breakaddlineDesc"),
+  params: [
+    {
+      name: "file",
+      type: "string",
+      description: lookup("breakaddlineFileDesc")
+    },
+    {
+      name: "line",
+      type: { name: "number", min: 0, step: 10 },
+      description: lookup("breakaddlineLineDesc")
+    },
+    {
+      group: "Options",
+      params: [
+        {
+         name: "if",
+         type: "string",
+         description: lookup("breakaddIfDesc"),
+         defaultValue: null
+        },
+      ]
+    }
+  ],
+  returnType: "html",
+  exec: function(args, context) {
+    args.type = "line";
+    breakpoints.push(args);
+    return lookup("breakaddAdded") + getBugLink(683503);
+  }
+});
+
+
+/**
+ * 'break add function' command
+ */
+gcli.addCommand({
+  name: "break add function",
+  description: lookup("breakaddfuncDesc"),
+  params: [
+    {
+      name: "function",
+      type: "javascript",
+      description: lookup("breakaddfuncFunctionDesc")
+    }
+  ],
+  returnType: "html",
+  exec: function(args, context) {
+    args.type = "function";
+    breakpoints.push(args);
+    return lookup("breakaddAdded") + getBugLink(683503);
+  }
+});
+
+
+/**
+ * 'break add xhr' command
+ */
+gcli.addCommand({
+  name: "break add xhr",
+  description: lookup("breakaddxhrDesc"),
+  returnType: "html",
+  exec: function(args, context) {
+    args.type = "xhr";
+    breakpoints.push(args);
+    return lookup("breakaddAdded") + getBugLink(683503);
+  }
+});
+
+
+/**
+ * 'break add event' command
+ */
+gcli.addCommand({
+  name: "break add event",
+  description: lookup("breakaddeventDesc"),
+  params: [
+    {
+      name: "event",
+      type: {
+        name: "selection",
+        data: [
+          "click", "dblclick", "mousedown", "mouseup", "mouseover", "mousemove",
+          "mouseout", "keydown", "keypress", "keyup", "load", "unload", "abort",
+          "error", "resize", "scroll", "select", "change", "submit", "reset",
+          "focus", "blur", "DOMFocusIn", "DOMFocusOut", "DOMActivate",
+          "DOMSubtreeModified", "DOMNodeInserted", "DOMNodeRemoved",
+          "DOMNodeRemovedFromDocument", "DOMNodeInsertedIntoDocument",
+          "DOMAttrModified", "DOMCharacterDataModified",
+          "touchstart", "touchend", "touchenter", "touchleave", "touchmove",
+          "touchcancel"
+        ]
+      },
+      description: lookup("breakaddeventEventDesc")
+    },
+    {
+      name: "node",
+      type: "node",
+      description: lookup("breakaddeventNodeDesc")
+    },
+  ],
+  returnType: "html",
+  exec: function(args, context) {
+    args.type = "event";
+    args.node = args.node.__gcliQuery;
+    breakpoints.push(args);
+    return lookup("breakaddAdded") + getBugLink(683503);
+  }
+});
+
+
+/**
+ * 'break next' command
+ */
+gcli.addCommand({
+  name: "break next",
+  description: lookup("breaknextDesc"),
+  returnType: "html",
+  exec: function(args, context) {
+    return lookup("breaknextReply") + getBugLink(683503);
+  }
+});
+
+
+/**
+ * 'break del' command
+ */
+gcli.addCommand({
+  name: "break del",
+  description: lookup("breakdelDesc"),
+  params: [
+    {
+      name: "breakid",
+      type: {
+        name: "number",
+        min: 0,
+        max: function() { return breakpoints.length - 1; }
+      },
+      description: lookup("breakdelBreakidDesc")
+    }
+  ],
+  returnType: "html",
+  exec: function(args, context) {
+    breakpoints.splice(args.breakid, 1);
+    return lookup("breakdelRemoved") + getBugLink(683503);
+  }
+});
+
+
+/**
+ * 'step' command
+ */
+gcli.addCommand({
+  name: "step",
+  description: lookup("stepDesc"),
+  manual: lookup("stepManual")
+});
+
+
+/**
+ * 'step up' command
+ */
+gcli.addCommand({
+  name: "step up",
+  description: lookup("stepupDesc"),
+  manual: lookup("stepupManual"),
+  returnType: "html",
+  exec: function(args, context) {
+    return lookup("stepInsult") + getBugLink(683505);
+  }
+});
+
+
+/**
+ * 'step in' command
+ */
+gcli.addCommand({
+  name: "step in",
+  description: lookup("stepinDesc"),
+  manual: lookup("stepinManual"),
+  returnType: "html",
+  exec: function(args, context) {
+    return lookup("stepInsult") + getBugLink(683505);
+  }
+});
+
+
+/**
+ * 'step next' command
+ */
+gcli.addCommand({
+  name: "step next",
+  description: lookup("stepnextDesc"),
+  manual: lookup("stepnextManual"),
+  returnType: "html",
+  exec: function(args, context) {
+    return lookup("stepInsult") + getBugLink(683505);
+  }
+});
+
+
+/**
+ * 'step on' command
+ */
+gcli.addCommand({
+  name: "step on",
+  description: lookup("steponDesc"),
+  manual: lookup("steponManual"),
+  returnType: "html",
+  exec: function(args, context) {
+    return lookup("stepInsult") + getBugLink(683505);
+  }
+});
+
+
+/**
+ * 'step to' command
+ */
+gcli.addCommand({
+  name: "step to",
+  description: lookup("steptoDesc"),
+  manual: lookup("steptoManual"),
+  params: [
+    {
+      name: "line",
+      type: { name: "number", min: 0, step: 10 },
+      description: lookup("steptoLineDesc")
+    }
+  ],
+  returnType: "html",
+  exec: function(args, context) {
+    return lookup("stepInsult") + getBugLink(683505);
+  }
+});
+
+
+/**
+ * 'highlight' command
+ */
+gcli.addCommand({
+  name: "highlight",
+  description: lookup("highlightDesc"),
+  manual: lookup("highlightManual"),
+  params: [
+     {
+       name: "node",
+       type: "node",
+       description: lookup("highlightNodeDesc")
+     }
+   ],
+   returnType: "html",
+   exec: function(args, context) {
+     return lookupFormat("highlightReply", [ "" + args.node ]) +
+         getBugLink(683506);
+   }
+});
+
+
+/**
+ * 'inspect' command
+ */
+gcli.addCommand({
+  name: "inspect",
+  description: lookup("inspectDesc"),
+  manual: lookup("inspectManual"),
+  params: [
+     {
+       name: "node",
+       type: "node",
+       description: lookup("inspectNodeDesc")
+     }
+   ],
+   returnType: "html",
+   exec: function(args, context) {
+     return lookupFormat("inspectReply", [ "" + args.node ]) +
+         getBugLink(683508);
+   }
+});
+
+
+/**
+ * 'doctor' command
+ */
+gcli.addCommand({
+  name: "doctor",
+  description: lookup("doctorDesc"),
+  manual: lookup("doctorManual"),
+  params: [
+     {
+       name: "node",
+       type: "node",
+       description: lookup("doctorNodeDesc")
+     }
+   ],
+   returnType: "html",
+   exec: function(args, context) {
+     return lookupFormat("doctorReply", [ "" + args.node ]) +
+         getBugLink(683509);
+   }
+});
+
+
+/**
+ * 'echo' command
+ */
+gcli.addCommand({
+  name: "echo",
+  description: lookup("echoDesc"),
+  params: [
+    {
+      name: "message",
+      type: "string",
+      description: lookup("echoMessageDesc")
+    }
+  ],
+  returnType: "string",
+  exec: function echo(args, context) {
+    return args.message;
+  }
+});
+
+
+/**
+ * 'console' command
+ */
+gcli.addCommand({
+  name: "console",
+  description: lookup("consoleDesc"),
+  manual: lookup("consoleManual")
+});
+
+
+/**
+ * 'console clear' command
+ */
+gcli.addCommand({
+  name: "console clear",
+  description: lookup("consoleclearDesc"),
+  returnType: "html",
+  exec: function(args, context) {
+    return lookup("consoleclearReply") + getBugLink(683510);
+  }
+});
+
+
+/**
+ * 'console close' command
+ */
+gcli.addCommand({
+  name: "console close",
+  description: lookup("consolecloseDesc"),
+  returnType: "html",
+  exec: function(args, context) {
+    return lookup("consolecloseReply") + getBugLink(683510);
+  }
+});
+
+
+/**
+ * 'console filter' command
+ */
+gcli.addCommand({
+  name: "console filter",
+  description: lookup("consolefilterDesc"),
+  params: [
+    {
+      name: "category",
+      type: {
+        name: "selection",
+        data: [ "net", "css", "js", "page" ]
+      },
+      description: lookup("consolefilterCategoryDesc")
+    },
+    {
+      name: "level",
+      type: {
+        name: "selection",
+        data: [ "error", "warning", "log", "debug" ]
+      },
+      description: lookup("consolefilterLevelDesc")
+    },
+    {
+      name: "display",
+      type: {
+        name: "selection",
+        data: [ "show", "hide" ]
+      },
+      description: lookup("consolefilterDisplayDesc")
+    },
+  ],
+  returnType: "html",
+  exec: function(args, context) {
+    return lookup("consolefilterReply") + getBugLink(683510);
+  }
+});
+
+
+/**
+ * 'scratchpad' command
+ */
+gcli.addCommand({
+  name: "scratchpad",
+  description: lookup("scratchpadDesc"),
+  params: [
+    {
+      name: "script",
+      type: "string",
+      description: lookup("scratchpadScriptDesc"),
+      defaultValue: null
+    },
+    {
+      group: "Options",
+      params: [
+        /*
+        {
+          name: "file",
+          type: "file",
+          description: lookup("scratchpadFileDesc"),
+          defaultValue: null
+        },
+        */
+        {
+          name: "chrome",
+          type: "boolean",
+          description: lookup("scratchpadChromeDesc")
+        }
+      ]
+    }
+  ],
+  returnType: "html",
+  exec: function(args, context) {
+    // See Bug 659268 - we shouldn't need to do this
+    if (args.file && args.script) {
+      throw new Error(lookup("scratchpadOnesource"));
+    }
+    if (args.file) {
+      return '<textarea rows=5 cols=80 style="font-family:monospace">' +
+          lookupFormat("scratchpadFilepretend", [ args.file ]) +
+          "</textarea>" +
+          getBugLink(683513);
+    }
+    if (args.script) {
+      return '<textarea rows=5 cols=80 style="font-family:monospace">' +
+          lookup("scratchpadScriptpretend") +
+          ":\n" + args.script + "</textarea>" +
+          getBugLink(683513);
+    }
+    return '<textarea rows=5 cols=80 style="font-family:monospace">' +
+        lookup("scratchpadEmptypretend") + "</textarea>" +
+        getBugLink(683513);
+  }
+});
+
diff --git a/browser/devtools/webconsole/HUDService.jsm b/browser/devtools/webconsole/HUDService.jsm
--- a/browser/devtools/webconsole/HUDService.jsm
+++ b/browser/devtools/webconsole/HUDService.jsm
@@ -28,6 +28,7 @@
  *   Julian Viereck <jviereck@mozilla.com>
  *   Mihai Șucan <mihai.sucan@gmail.com>
  *   Michael Ratcliffe <mratcliffe@mozilla.com>
+ *   Joe Walker <jwalker@mozilla.com>
  *
  * Alternatively, the contents of this file may be used under the terms of
  * either the GNU General Public License Version 2 or later (the "GPL"), or
@@ -53,6 +54,8 @@ Cu.import("resource://gre/modules/XPCOMU
 Cu.import("resource://gre/modules/Services.jsm");
 Cu.import("resource:///modules/NetworkHelper.jsm");
 Cu.import("resource:///modules/PropertyPanel.jsm");
+Cu.import("resource:///modules/gcli.jsm");
+Cu.import("resource:///modules/Commands.jsm");
 
 var EXPORTED_SYMBOLS = ["HUDService", "ConsoleUtils"];
 
@@ -105,6 +108,17 @@ XPCOMUtils.defineLazyGetter(this, "Autoc
   return obj.AutocompletePopup;
 });
 
+XPCOMUtils.defineLazyGetter(this, "HintPopup", function () {
+  var obj = {};
+  try {
+    Cu.import("resource:///modules/HintPopup.jsm", obj);
+  }
+  catch (err) {
+    Cu.reportError(err);
+  }
+  return obj.HintPopup;
+});
+
 XPCOMUtils.defineLazyGetter(this, "namesAndValuesOf", function () {
   var obj = {};
   Cu.import("resource:///modules/PropertyPanel.jsm", obj);
@@ -1744,7 +1758,9 @@ HUD_SERVICE.prototype =
     // Remove children from the output. If the output is not cleared, there can
     // be leaks as some nodes has node.onclick = function; set and GC can't
     // remove the nodes then.
-    hud.jsterm.clearOutput();
+    if (hud.jsterm) {
+      hud.jsterm.clearOutput();
+    }
 
     hud.destroy();
 
@@ -1763,7 +1779,9 @@ HUD_SERVICE.prototype =
       hud.splitter.parentNode.removeChild(hud.splitter);
     }
 
-    hud.jsterm.autocompletePopup.destroy();
+    if (hud.jsterm) {
+      hud.jsterm.autocompletePopup.destroy();
+    }
 
     delete this.hudReferences[aHUDId];
 
@@ -2600,9 +2618,24 @@ HUD_SERVICE.prototype =
     // create Initial JS Workspace:
     var context = Cu.getWeakReference(aContext);
 
+    let usegcli = false;
+    try {
+      usegcli = Services.prefs.getBoolPref("devtools.gcli.enable");
+    }
+    catch (ex) {}
+
     // Attach the UI into the target parent node using the mixin.
-    var firefoxMixin = new JSTermFirefoxMixin(context, aParentNode);
-    var jsTerm = new JSTerm(context, aParentNode, firefoxMixin, aConsole);
+    if (!usegcli) {
+      var firefoxMixin = new JSTermFirefoxMixin(context, aParentNode);
+      var jsTerm = new JSTerm(context, aParentNode, firefoxMixin, aConsole);
+    }
+    else {
+      let hudId = getHudIdFromNode(aParentNode);
+      let doc = aParentNode.ownerDocument;
+
+      var gcliterm = new GcliTerm(context, hudId, doc, aConsole);
+      aParentNode.appendChild(gcliterm.element);
+    }
 
     // TODO: injection of additional functionality needs re-thinking/api
     // see bug 559748
@@ -2962,6 +2995,30 @@ HUD_SERVICE.prototype =
   }
 };
 
+/**
+ * Get the HudId from an element contained inside the HUD.
+ * This is nasty nasty code, but rather than re-architect I'm just going to
+ * document what I think is going on here. The refactoring should be done in a
+ * separate bug.
+ * We want a reference to the main HUD so we can add output to it, and rather
+ * than passing a reference to that console around, we look it up via an id.
+ * However we don't have that either so we walk up the tree to find the first
+ * thing that has an id, and make the assumption that this is the correct one.
+ * For reference, what we're looking for is vbox.hud-box.animated which is
+ * created high up in makeHUDNodes(). I think.
+ * @see JSTerm constructor where this code comes from
+ * @see Bug 592469
+ * @param nsIDOMNode aNode The node to search from
+ * @return string The HUD ID
+ */
+function getHudIdFromNode(aNode) {
+  let node = aNode;
+  while (!node.hasAttribute("id")) {
+    node = node.parentNode;
+  }
+  return node.getAttribute("id");
+}
+
 //////////////////////////////////////////////////////////////////////////
 // HeadsUpDisplay
 //////////////////////////////////////////////////////////////////////////
@@ -3068,7 +3125,12 @@ function HeadsUpDisplay(aConfig)
   // create the JSTerm input element
   try {
     this.createConsoleInput(this.contentWindow, this.consoleWrap, this.outputNode);
-    this.jsterm.inputNode.focus();
+    if (!this.usegcli) {
+      this.jsterm.inputNode.focus();
+    }
+    else {
+      this.gcliterm.inputNode.focus();
+    }
   }
   catch (ex) {
     Cu.reportError(ex);
@@ -3181,9 +3243,12 @@ HeadsUpDisplay.prototype = {
         this.outputNode.ensureIndexIsVisible(lastIndex);
       }
 
-      if (this.jsterm) {
+      if (!this.usegcli) {
         this.jsterm.inputNode.focus();
       }
+      else {
+        this.gcliterm.inputNode.focus();
+      }
     }).bind(this);
 
     panel.addEventListener("popupshown", onPopupShown,false);
@@ -3372,8 +3437,15 @@ HeadsUpDisplay.prototype = {
       this.consolePanel.hidePopup();
     }
 
-    if (this.jsterm) {
-      this.jsterm.inputNode.focus();
+    if (!this.usegcli) {
+      if (this.jsterm) {
+        this.jsterm.inputNode.focus();
+      }
+    }
+    else {
+      if (this.gcliterm) {
+        this.gcliterm.inputNode.focus();
+      }
     }
   },
 
@@ -3407,6 +3479,12 @@ HeadsUpDisplay.prototype = {
   jsterm: null,
 
   /**
+   * The GcliTerm object that contains the console's GCLI
+   *
+   */
+  gcliterm: null,
+
+  /**
    * creates and attaches the console input node
    *
    * @param nsIDOMWindow aWindow
@@ -3417,10 +3495,23 @@ HeadsUpDisplay.prototype = {
   {
     var context = Cu.getWeakReference(aWindow);
 
+    this.usegcli = false;
+    try {
+      this.usegcli = Services.prefs.getBoolPref("devtools.gcli.enable");
+    }
+    catch (ex) {}
+
     if (appName() == "FIREFOX") {
-      let mixin = new JSTermFirefoxMixin(context, aParentNode,
-                                         aExistingConsole);
-      this.jsterm = new JSTerm(context, aParentNode, mixin, this.console);
+      if (!this.usegcli) {
+        let mixin = new JSTermFirefoxMixin(context, aParentNode,
+                                           aExistingConsole);
+        this.jsterm = new JSTerm(context, aParentNode, mixin, this.console);
+      }
+      else {
+        this.gcliterm = new GcliTerm(context, this.hudId, this.chromeDocument,
+                                     this.console);
+        aParentNode.appendChild(this.gcliterm.element);
+      }
     }
     else {
       throw new Error("Unsupported Gecko Application");
@@ -3450,6 +3541,8 @@ HeadsUpDisplay.prototype = {
       this.jsterm.context = Cu.getWeakReference(this.contentWindow);
       this.jsterm.console = this.console;
       this.jsterm.createSandbox();
+
+      this.gcliterm.reattachConsole(this.contentWindow, this.console);
     }
   },
 
@@ -3902,7 +3995,9 @@ HeadsUpDisplay.prototype = {
    */
   destroy: function HUD_destroy()
   {
-    this.jsterm.destroy();
+    if (this.jsterm) {
+      this.jsterm.destroy();
+    }
 
     this.positionMenuitems.above.removeEventListener("command",
       this._positionConsoleAbove, false);
@@ -5396,6 +5491,7 @@ JSTermFirefoxMixin.prototype = {
     this.completeNode.setAttribute("class", "jsterm-complete-node");
     this.completeNode.setAttribute("multiline", "true");
     this.completeNode.setAttribute("rows", "1");
+    this.completeNode.setAttribute("tabindex", "-1");
 
     this.inputNode = this.xulElementFactory("textbox");
     this.inputNode.setAttribute("class", "jsterm-input-node");
@@ -5409,22 +5505,15 @@ JSTermFirefoxMixin.prototype = {
     inputStack.appendChild(this.inputNode);
 
     if (this.existingConsoleNode == undefined) {
-      this.outputNode = this.xulElementFactory("vbox");
-      this.outputNode.setAttribute("class", "jsterm-output-node");
-
-      this.term = this.xulElementFactory("vbox");
-      this.term.setAttribute("class", "jsterm-wrapper-node");
-      this.term.setAttribute("flex", "1");
-      this.term.appendChild(this.outputNode);
-    }
-    else {
-      this.outputNode = this.existingConsoleNode;
-
-      this.term = this.xulElementFactory("hbox");
-      this.term.setAttribute("class", "jsterm-input-container");
-      this.term.setAttribute("style", "direction: ltr;");
-      this.term.appendChild(inputStack);
-    }
+      throw new Error("This can't happen");
+    }
+
+    this.outputNode = this.existingConsoleNode;
+
+    this.term = this.xulElementFactory("hbox");
+    this.term.setAttribute("class", "jsterm-input-container");
+    this.term.setAttribute("style", "direction: ltr;");
+    this.term.appendChild(inputStack);
   },
 
   get inputValue()
@@ -5554,9 +5643,8 @@ ConsoleUtils = {
   function ConsoleUtils_createMessageNode(aDocument, aCategory, aSeverity,
                                           aBody, aSourceURL, aSourceLine,
                                           aClipboardText, aLevel) {
-    if (aBody instanceof Ci.nsIDOMNode && aClipboardText == null) {
-      throw new Error("HUDService.createMessageNode(): DOM node supplied " +
-                      "without any clipboard text");
+    if (typeof aBody != "string" && aClipboardText == null && aBody.innerText) {
+      aClipboardText = aBody.innerText;
     }
 
     // Make the icon container, which is a vertical box. Its purpose is to
@@ -5592,6 +5680,13 @@ ConsoleUtils = {
     aBody = aBody instanceof Ci.nsIDOMNode && !(aLevel == "dir") ?
             aBody : aDocument.createTextNode(aBody);
 
+    if (!aBody.nodeType) {
+      aBody = aDocument.createTextNode(aBody.toString());
+    }
+    if (typeof aBody == "string") {
+      aBody = aDocument.createTextNode(aBody);
+    }
+
     bodyNode.appendChild(aBody);
 
     let repeatContainer = aDocument.createElementNS(XUL_NS, "hbox");
@@ -6720,3 +6815,341 @@ catch (ex) {
   // TODO: kill anything that may have started up
   // see bug 568665
 }
+
+///////////////////////////////////////////////////////////////////////////
+// GcliTerm
+///////////////////////////////////////////////////////////////////////////
+
+/**
+ * GcliTerm
+ *
+ * Create a GcliTerminal or attach a GcliTerm input node to an existing output
+ * node, given by the parent node.
+ *
+ * @param object aContext
+ *        Usually a weak reference to an nsIDOMWindow, however this code
+ *        follows the convention of JSTerm where the context does not have to
+ *        be to a window.
+ * @param string aHudId
+ *        The HUD to which we should send console messages
+ * @param nsIDOMDocument aDocument
+ *        The DOM document from which to create nodes
+ * @param object aConsole
+ *        Console object to use within the GcliTerm
+ * @constructor
+ */
+function GcliTerm(aContext, aHudId, aDocument, aConsole)
+{
+  this.context = aContext;
+  this.hudId = aHudId;
+  this.document = aDocument;
+  this.console = aConsole;
+
+  this.createUI();
+  this.createSandbox();
+
+  gcli._internal.commandOutputManager.addListener(this.onCommandOutput, this);
+  gcli._internal.createView({
+    document: this.document,
+    jsEnvironment: {
+      globalObject: this.context.get().QueryInterface(Ci.nsIDOMWindow),
+      evalFunction: this.evalInSandbox.bind(this)
+    },
+    inputElement: this.inputNode,
+    completeElement: this.completeNode,
+    inputBackgroundElement: this.inputStack,
+    completionPrompt: ""
+  });
+}
+
+GcliTerm.prototype = {
+  /**
+   * Re-attaches a console when the contentWindow is recreated
+   *
+   * @param nsIDOMWindow aContentWindow
+   *        Usually a nsIDOMWindow, however see the comments against the
+   *        aContext parameter in the GcliTerm constructor. Also note the
+   *        asymmetry between how this function creates the WeakReference where
+   *        the constructor expects the caller to create it. Yuck.
+   * @param object aConsole
+   *        Console object to use within the GcliTerm
+   */
+  reattachConsole: function Gcli_reattachConsole(aContentWindow, aConsole)
+  {
+    this.context = Cu.getWeakReference(aContentWindow);
+    this.console = aConsole;
+    this.createSandbox();
+  },
+
+  /**
+   * Generates and attaches the GCLI Terminal part of the Web Console, which
+   * essentially consists of the interactive JavaScript input facility.
+   */
+  createUI: function Gcli_createUI()
+  {
+    this.element = this.document.createElement("vbox");
+    this.element.setAttribute("class", "gcliterm-input-container");
+
+    this.inputStack = this.document.createElement("stack");
+    this.inputStack.setAttribute("class", "gcliterm-stack-node");
+    this.element.appendChild(this.inputStack);
+
+    this.completeNode = this.document.createElement("div");
+    this.completeNode.setAttribute("class", "gcliterm-complete-node");
+    this.completeNode.setAttribute("aria-live", "polite");
+    this.inputStack.appendChild(this.completeNode);
+
+    this.inputNode = this.document.createElement("textbox");
+    this.inputNode.setAttribute("class", "gcliterm-input-node");
+    this.inputNode.setAttribute("rows", "1");
+    this.inputStack.appendChild(this.inputNode);
+  },
+
+  /**
+   * Called by GCLI/canon when command line output changes
+   */
+  onCommandOutput: function Gcli_onCommandOutput(aEvent)
+  {
+    // When we can update the history of the console, then we should stop
+    // filtering incomplete reports.
+    if (!aEvent.output.completed) {
+      return;
+    }
+
+    this.writeOutput(aEvent.output.typed, { category: CATEGORY_INPUT });
+
+    let output = aEvent.output.output;
+    if (aEvent.output.command.returnType == "html" && typeof output == "string") {
+      let frag = this.document.createRange().createContextualFragment(
+          '<div xmlns="' + HTML_NS + '" xmlns:xul="' + XUL_NS + '">' +
+          output + '</div>');
+
+      output = this.document.createElementNS(HTML_NS, "div");
+      output.appendChild(frag);
+    }
+    this.writeOutput(output);
+  },
+
+  /**
+   * Setup the eval sandbox, should be called whenever we are attached
+   */
+  createSandbox: function Gcli_createSandbox()
+  {
+    let win = this.context.get().QueryInterface(Ci.nsIDOMWindow);
+
+    // create a JS Sandbox out of this.context
+    this.sandbox = new Cu.Sandbox(win, {
+      sandboxPrototype: win,
+      wantXrays: false
+    });
+    this.sandbox.console = this.console;
+  },
+
+  /**
+   * Evaluates a string in the sandbox. The string is currently wrapped by a
+   * with(window) { aString } construct, see bug 574033.
+   *
+   * @param string aString
+   *        String to evaluate in the sandbox
+   * @return The result of the evaluation
+   */
+  evalInSandbox: function Gcli_evalInSandbox(aString)
+  {
+    return Cu.evalInSandbox(aString, this.sandbox, "1.8", "Web Console", 1);
+  },
+
+  /**
+   * Builds on evalInSandbox, adding output of aExecuteString and the
+   * results of evaling that to the console output.
+   *
+   * @param string aExecuteString
+   *        The String to evalutate
+   */
+  execute: function Gcli_execute(aExecuteString)
+  {
+    // attempt to execute the content of the inputNode
+    aExecuteString = aExecuteString || this.inputNode.value;
+    if (!aExecuteString) {
+      this.writeOutput("no value to execute");
+      return;
+    }
+
+    this.writeOutput(aExecuteString, { category: CATEGORY_INPUT });
+
+    try {
+      this.helperEvaluated = false;
+      let result = this.evalInSandbox(aExecuteString);
+
+      // Hide undefined results coming from helpers.
+      let shouldShow = !(result === undefined && this.helperEvaluated);
+      if (shouldShow) {
+        let resultString = this._formatResult(result)
+
+        this.writeOutput(resultString);
+      }
+    }
+    catch (ex) {
+      this.writeOutput("" + ex, { severity: SEVERITY_ERROR });
+    }
+
+    this._setInputValue("");
+  },
+
+  /**
+   * Writes a message to the HUD that originates from the interactive
+   * JavaScript console.
+   *
+   * @param string aOutputMessage
+   *        The message to display
+   * @param number aCategory
+   *        One of the CATEGORY_ constants
+   * @param number aSeverity
+   *        One of the SEVERITY_ constants
+   */
+  writeOutput: function Gcli_writeOutput(aOutputMessage, aOptions)
+  {
+    aOptions = aOptions || {};
+
+    let node = ConsoleUtils.createMessageNode(
+                    this.document,
+                    aOptions.category || CATEGORY_OUTPUT,
+                    aOptions.severity || SEVERITY_LOG,
+                    aOutputMessage,
+                    aOptions.sourceUrl || undefined,
+                    aOptions.sourceLine || undefined,
+                    aOptions.clipboardText || undefined);
+
+    ConsoleUtils.outputMessageNode(node, this.hudId);
+  },
+
+  /**
+   * Remove all output from the HUD
+   */
+  clearOutput: function Gcli_clearOutput()
+  {
+    let hudRef = HUDService.getHudReferenceById(this.console);
+    if (hudRef) {
+      hudRef.cssNodes = {};
+    }
+
+    while (this.console.firstChild) {
+      this.console.removeChild(this.console.firstChild);
+    }
+
+    let hudBox = this.console;
+    while (!hudBox.classList.contains("hud-box")) {
+      hudBox = hudBox.parentNode;
+    }
+    hudBox.lastTimestamp = 0;
+  },
+
+  _formatResult: JSTerm.prototype.formatResult,
+  _formatString: JSTerm.prototype.formatString,
+  _getResultType: JSTerm.prototype.getResultType,
+
+  /**
+   * Sets the value of the input field (command line), and resizes the field to
+   * fit its contents. This method is preferred over setting "inputNode.value"
+   * directly, because it correctly resizes the field.
+   *
+   * @param string aNewValue
+   *        The new value to set
+   */
+  _setInputValue: function Gcli_setInputValue(aNewValue)
+  {
+    this.inputNode.value = aNewValue;
+    this.completeNode.value = "";
+  },
+};
+
+/*
+
+Unaddressed review comments:
+
+> @@ +3512,5 @@
+> >        this.jsterm.context = Cu.getWeakReference(this.contentWindow);
+> >        this.jsterm.console = this.console;
+> >        this.jsterm.createSandbox();
+> > +
+> > +      this.gcliterm.reattachConsole(this.contentWindow, this.console);
+> 
+> This code assumes that jsterm is available, but the new line you added
+> assume that gcliterm is *also* available. I doubt this code works properly.
+> This needs to be fixed.
+
+This is bizarre. I'll work out what's going on.
+
+
+GcliTerm.execute and GcliTerm.clearOutput are unused. The should be used or deleted
+
+> @@ +61,5 @@
+> > +
+> > +function testCallCommands() {
+> > +  let console = browser.contentWindow.wrappedJSObject.console;
+> > +
+> > +  let hudId = HUDService.displaysIndex()[0];
+> 
+> displaysIndex() has been removed, and other methods used by this test.
+> Please update. :)
+> 
+> @@ +78,5 @@
+> > +  gcliterm._setInputValue("ec");
+> > +  event = browser.createEvent("KeyboardEvent");
+> > +  event.initKeyEvent("keyup", true, true, null, false,
+> > +                     false, false, false, 80, 0);
+> > +  gcliterm.inputNode.dispatchEvent(event);
+> 
+> Please use EventUtils.synthesizeKey() instead of synthetic keyboard events.
+
+
+
+> ::: toolkit/themes/gnomestripe/global/webConsole.css
+> @@ +337,5 @@
+> > +  border-bottom: 2px dotted #999;
+> > +}
+> > +
+> > +.gcliterm-complete-node span.gcliERROR {
+> > +  color: #DDD; border-bottom: 2px dotted #F00;
+> 
+> Please put each property on a new line.
+> 
+> @@ +341,5 @@
+> > +  color: #DDD; border-bottom: 2px dotted #F00;
+> > +}
+> > +
+> > +.gcliterm-complete-node span.gcliPrompt {
+> > +  color: #66F; font-weight: bold;
+> 
+> Same as above.
+> 
+> (same comments apply to the other two stylesheets)
+
+
+
+> > > @@ +6787,5 @@
+> > > > +{
+> > > > +  this.context = aContext;
+> > > > +  this.hudId = aHudId;
+> > > > +  this.document = aDocument;
+> > > > +  this.console = aConsole;
+> > > 
+> > > this.console refers to the window.console API object in HeadsUpDisplay
+> > > objects. In clearOutput() you use this.console as if it refers to the
+> > > outputNode of a HUD object. This is confusing. Please fix.
+> > 
+> > It's exactly as confusing as JSTerm ...
+> > 
+> > Perhaps the confusion is the reattachConsole() method?
+> 
+> Code's not great, indeed, but I believe there's no such confusion in JSTerm.
+> In JSTerm this.console is well known to refer to the window.console API, and
+> this.outputNode is always outputNode. GCLITerm in turn confuses the two.
+> 
+> The confusion is in clearOutput(), not in reattachConsole(). (both in
+> GCLITerm) Please recheck. Thank you!
+
+
+You do not need to change initializeJSTerm
+
+*/
+
diff --git a/browser/devtools/webconsole/HintPopup.jsm b/browser/devtools/webconsole/HintPopup.jsm
new file mode 100644
--- /dev/null
+++ b/browser/devtools/webconsole/HintPopup.jsm
@@ -0,0 +1,402 @@
+/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Hint Popup.
+ *
+ * The Initial Developer of the Original Code is
+ * The Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 2011
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Mihai Sucan <mihai.sucan@gmail.com> (original author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+
+const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
+
+const HUD_STRINGS_URI = "chrome://global/locale/headsUpDisplay.properties";
+
+
+Components.utils.import("resource://gre/modules/Services.jsm");
+Components.utils.import("resource://gre/modules/XPCOMUtils.jsm");
+
+XPCOMUtils.defineLazyGetter(this, "stringBundle", function () {
+  return Services.strings.createBundle(HUD_STRINGS_URI);
+});
+
+
+var EXPORTED_SYMBOLS = [ "HintPopup" ];
+
+/**
+ * Autocomplete popup UI implementation.
+ *
+ * @constructor
+ * @param nsIDOMDocument aDocument
+ *        The document you want the popup attached to.
+ * @param {nsIDOMElement} aParent
+ *        The node to display inside the popup
+ */
+function AutocompletePopup(aDocument, aParent)
+{
+  this._document = aDocument;
+
+  // Reuse the existing popup elements.
+  this._panel = this._document.getElementById("webConsole_autocompletePopup");
+  if (!this._panel) {
+    this._panel = this._document.createElementNS(XUL_NS, "panel");
+    this._panel.setAttribute("id", "webConsole_autocompletePopup");
+    this._panel.setAttribute("label",
+      stringBundle.GetStringFromName("Autocomplete.label"));
+    this._panel.setAttribute("noautofocus", "true");
+    this._panel.setAttribute("ignorekeys", "true");
+    this._panel.setAttribute("level", "top");
+
+    let mainPopupSet = this._document.getElementById("mainPopupSet");
+    if (mainPopupSet) {
+      mainPopupSet.appendChild(this._panel);
+    }
+    else {
+      this._document.documentElement.appendChild(this._panel);
+    }
+
+    this._panel.appendChild(aParent);
+
+    // Open and hide the panel, so we initialize the API of the richlistbox.
+    this._panel.width = 1;
+    this._panel.height = 1;
+    this._panel.openPopup(null, "overlap", 0, 0, false, false);
+    this._panel.hidePopup();
+    this._panel.width = "";
+    this._panel.height = "";
+  }
+  else {
+    this._list = aParent;
+  }
+}
+
+// TODO: continue going through this removing _list
+
+AutocompletePopup.prototype = {
+  _document: null,
+  _panel: null,
+  _list: null,
+
+  /**
+   * Open the autocomplete popup panel.
+   *
+   * @param nsIDOMNode aAnchor
+   *        Optional node to anchor the panel to.
+   */
+  openPopup: function AP_openPopup(aAnchor)
+  {
+    this._panel.openPopup(aAnchor, "after_start", 0, 0, false, false);
+
+    if (this.onSelect) {
+      this._list.addEventListener("select", this.onSelect, false);
+    }
+
+    if (this.onClick) {
+      this._list.addEventListener("click", this.onClick, false);
+    }
+
+    this._updateSize();
+  },
+
+  /**
+   * Hide the autocomplete popup panel.
+   */
+  hidePopup: function AP_hidePopup()
+  {
+    this._panel.hidePopup();
+
+    if (this.onSelect) {
+      this._list.removeEventListener("select", this.onSelect, false);
+    }
+
+    if (this.onClick) {
+      this._list.removeEventListener("click", this.onClick, false);
+    }
+  },
+
+  /**
+   * Check if the autocomplete popup is open.
+   */
+  get isOpen() {
+    return this._panel.state == "open";
+  },
+
+  /**
+   * Destroy the object instance. Please note that the panel DOM elements remain
+   * in the DOM, because they might still be in use by other instances of the
+   * same code. It is the responsability of the client code to perform DOM
+   * cleanup.
+   */
+  destroy: function AP_destroy()
+  {
+    if (this.isOpen) {
+      this.hidePopup();
+    }
+    this.clearItems();
+
+    this._document = null;
+    this._list = null;
+    this._panel = null;
+  },
+
+  /**
+   * Get the autocomplete items array.
+   *
+   * @return array
+   *         The array of autocomplete items.
+   */
+  getItems: function AP_getItems()
+  {
+    let items = [];
+
+    Array.forEach(this._list.childNodes, function(aItem) {
+      items.push(aItem._autocompleteItem);
+    });
+
+    return items;
+  },
+
+  /**
+   * Set the autocomplete items list, in one go.
+   *
+   * @param array aItems
+   *        The list of items you want displayed in the popup list.
+   */
+  setItems: function AP_setItems(aItems)
+  {
+    this.clearItems();
+    aItems.forEach(this.appendItem, this);
+
+    // Make sure that the new content is properly fitted by the XUL richlistbox.
+    if (this.isOpen) {
+      // We need the timeout to allow the content to reflow. Attempting to
+      // update the richlistbox size too early does not work.
+      this._document.defaultView.setTimeout(this._updateSize.bind(this), 1);
+    }
+  },
+
+  /**
+   * Update the panel size to fit the content.
+   *
+   * @private
+   */
+  _updateSize: function AP__updateSize()
+  {
+    this._list.width = this._panel.clientWidth +
+                       this._scrollbarWidth;
+  },
+
+  /**
+   * Clear all the items from the autocomplete list.
+   */
+  clearItems: function AP_clearItems()
+  {
+    while (this._list.hasChildNodes()) {
+      this._list.removeChild(this._list.firstChild);
+    }
+
+    // Reset the panel and list dimensions. New dimensions are calculated when a
+    // new set of items is added to the autocomplete popup.
+    this._list.width = "";
+    this._list.height = "";
+    this._panel.width = "";
+    this._panel.height = "";
+    this._panel.top = "";
+    this._panel.left = "";
+  },
+
+  /**
+   * Getter for the index of the selected item.
+   *
+   * @type number
+   */
+  get selectedIndex() {
+    return this._list.selectedIndex;
+  },
+
+  /**
+   * Setter for the selected index.
+   *
+   * @param number aIndex
+   *        The number (index) of the item you want to select in the list.
+   */
+  set selectedIndex(aIndex) {
+    this._list.selectedIndex = aIndex;
+    this._list.ensureIndexIsVisible(this._list.selectedIndex);
+  },
+
+  /**
+   * Getter for the selected item.
+   * @type object
+   */
+  get selectedItem() {
+    return this._list.selectedItem ?
+           this._list.selectedItem._autocompleteItem : null;
+  },
+
+  /**
+   * Setter for the selected item.
+   *
+   * @param object aItem
+   *        The object you want selected in the list.
+   */
+  set selectedItem(aItem) {
+    this._list.selectedItem = this._findListItem(aItem);
+    this._list.ensureIndexIsVisible(this._list.selectedIndex);
+  },
+
+  /**
+   * Append an item into the autocomplete list.
+   *
+   * @param object aItem
+   *        The item you want appended to the list. The object must have a
+   *        "label" property which is used as the displayed value.
+   */
+  appendItem: function AP_appendItem(aItem)
+  {
+    let description = this._document.createElementNS(XUL_NS, "description");
+    description.textContent = aItem.label;
+
+    let listItem = this._document.createElementNS(XUL_NS, "richlistitem");
+    listItem.appendChild(description);
+    listItem._autocompleteItem = aItem;
+
+    this._list.appendChild(listItem);
+  },
+
+  /**
+   * Find the richlistitem element that belongs to an item.
+   *
+   * @private
+   *
+   * @param object aItem
+   *        The object you want found in the list.
+   *
+   * @return nsIDOMNode|null
+   *         The nsIDOMNode that belongs to the given item object. This node is
+   *         the richlistitem element.
+   */
+  _findListItem: function AP__findListItem(aItem)
+  {
+    for (let i = 0; i < this._list.childNodes.length; i++) {
+      let child = this._list.childNodes[i];
+      if (child._autocompleteItem == aItem) {
+        return child;
+      }
+    }
+    return null;
+  },
+
+  /**
+   * Remove an item from the popup list.
+   *
+   * @param object aItem
+   *        The item you want removed.
+   */
+  removeItem: function AP_removeItem(aItem)
+  {
+    let item = this._findListItem(aItem);
+    if (!item) {
+      throw new Error("Item not found!");
+    }
+    this._list.removeChild(item);
+  },
+
+  /**
+   * Getter for the number of items in the popup.
+   * @type number
+   */
+  get itemCount() {
+    return this._list.childNodes.length;
+  },
+
+  /**
+   * Select the next item in the list.
+   *
+   * @return object
+   *         The newly selected item object.
+   */
+  selectNextItem: function AP_selectNextItem()
+  {
+    if (this.selectedIndex < (this.itemCount - 1)) {
+      this.selectedIndex++;
+    }
+    else {
+      this.selectedIndex = -1;
+    }
+
+    return this.selectedItem;
+  },
+
+  /**
+   * Select the previous item in the list.
+   *
+   * @return object
+   *         The newly selected item object.
+   */
+  selectPreviousItem: function AP_selectPreviousItem()
+  {
+    if (this.selectedIndex > -1) {
+      this.selectedIndex--;
+    }
+    else {
+      this.selectedIndex = this.itemCount - 1;
+    }
+
+    return this.selectedItem;
+  },
+
+  /**
+   * Determine the scrollbar width in the current document.
+   *
+   * @private
+   */
+  get _scrollbarWidth()
+  {
+    if (this.__scrollbarWidth) {
+      return this.__scrollbarWidth;
+    }
+
+    let hbox = this._document.createElementNS(XUL_NS, "hbox");
+    hbox.setAttribute("style", "height: 0%; overflow: hidden");
+
+    let scrollbar = this._document.createElementNS(XUL_NS, "scrollbar");
+    scrollbar.setAttribute("orient", "vertical");
+    hbox.appendChild(scrollbar);
+
+    this._document.documentElement.appendChild(hbox);
+    this.__scrollbarWidth = scrollbar.clientWidth;
+    this._document.documentElement.removeChild(hbox);
+
+    return this.__scrollbarWidth;
+  },
+};
diff --git a/browser/devtools/webconsole/Makefile.in b/browser/devtools/webconsole/Makefile.in
--- a/browser/devtools/webconsole/Makefile.in
+++ b/browser/devtools/webconsole/Makefile.in
@@ -50,6 +50,7 @@ EXTRA_JS_MODULES = \
 		NetworkHelper.jsm \
 		AutocompletePopup.jsm \
 		gcli.jsm \
+		Commands.jsm \
 		$(NULL)
 
 ifdef ENABLE_TESTS
diff --git a/browser/devtools/webconsole/test/browser/Makefile.in b/browser/devtools/webconsole/test/browser/Makefile.in
--- a/browser/devtools/webconsole/test/browser/Makefile.in
+++ b/browser/devtools/webconsole/test/browser/Makefile.in
@@ -109,6 +109,7 @@ _BROWSER_TEST_FILES = \
 	browser_webconsole_bug_601177_log_levels.js \
 	browser_webconsole_bug_597460_filter_scroll.js \
 	browser_webconsole_gcli_require.js \
+	browser_webconsole_gcli_integrate.js \
 	browser_webconsole_console_extras.js \
 	browser_webconsole_bug_598357_jsterm_output.js \
 	browser_webconsole_bug_603750_websocket.js \
diff --git a/browser/devtools/webconsole/test/browser/browser_webconsole_gcli_integrate.js b/browser/devtools/webconsole/test/browser/browser_webconsole_gcli_integrate.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/webconsole/test/browser/browser_webconsole_gcli_integrate.js
@@ -0,0 +1,113 @@
+/* Any copyright is dedicated to the Public Domain.
+ * http://creativecommons.org/publicdomain/zero/1.0/ */
+
+// Tests that source URLs in the Web Console can be clicked to display the
+// standard View Source window.
+
+Components.utils.import("resource:///modules/gcli.jsm");
+let require = gcli._internal.require;
+
+const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/browser/test-console.html";
+
+registerCleanupFunction(function() {
+    Services.prefs.setBoolPref("devtools.gcli.enable", false);
+});
+
+function test() {
+  Services.prefs.setBoolPref("devtools.gcli.enable", true);
+  addTab(TEST_URI);
+  browser.addEventListener("DOMContentLoaded", onLoad, false);
+}
+
+function onLoad() {
+  browser.removeEventListener("DOMContentLoaded", onLoad, false);
+  openConsole();
+
+  try {
+    testCreateCommands();
+    testCallCommands();
+    testRemoveCommands();
+  }
+  catch (ex) {
+    console.error(ex);
+  }
+  finally {
+    closeConsole();
+    finishTest();
+    console.log("test finished");
+  }
+}
+
+let tselarr = {
+  name: 'tselarr',
+  params: [
+    { name: 'num', type: { name: 'selection', data: [ '1', '2', '3' ] } },
+    { name: 'arr', type: { name: 'array', subtype: 'string' } },
+  ],
+  exec: function(args, env) {
+    return "flu " + args.num + "-" + args.arr.join("_");
+  }
+};
+
+function testCreateCommands() {
+  let gcli = require("gcli/index");
+  gcli.addCommand(tselarr);
+
+  let canon = require("gcli/canon");
+  let tselcmd = canon.getCommand("tselarr");
+  ok(tselcmd != null, "tselarr exists in the canon");
+  is(typeof tselcmd.getDescription, "function", "canon storing commands");
+}
+
+function testCallCommands() {
+  let console = browser.contentWindow.wrappedJSObject.console;
+
+  let hudId = HUDService.displaysIndex()[0];
+  let hud = HUDService.hudReferences[hudId];
+  ok(hud, "There is a console");
+
+  let hudBox = HUDService.getHeadsUpDisplay(hudId);
+  ok(hudBox, "We have a console display");
+
+  let gcliterm = hud.gcliterm;
+  ok(gcliterm, "We have a GCLI term");
+
+  let event;
+
+  // Test successful auto-completion
+  gcliterm._setInputValue("ec");
+  event = browser.createEvent("KeyboardEvent");
+  event.initKeyEvent("keyup", true, true, null, false,
+                     false, false, false, 80, 0);
+  gcliterm.inputNode.dispatchEvent(event);
+  is(gcliterm.completeNode.value, "  ho", "Completion for \"ec\"");
+
+  // Test unsuccessful auto-completion
+  gcliterm._setInputValue("ecd");
+  event = browser.createEvent("KeyboardEvent");
+  event.initKeyEvent("keyup", true, true, null, false,
+                     false, false, false, 81, 0);
+  gcliterm.inputNode.dispatchEvent(event);
+  is(gcliterm.completeNode.value.replace(" ", ""), "", "Completion for \"ecd\"");
+
+  let outputNode = hudBox.querySelector(".hud-output-node");
+
+  // Test a normal command's life cycle
+  gcliterm._setInputValue("echo hello world");
+  event = browser.createEvent("KeyboardEvent");
+  event.initKeyEvent("keyup", true, true, null, false,
+                     false, false, false, 13, 0);
+  gcliterm.inputNode.dispatchEvent(event);
+  let node = outputNode.querySelector(".hud-msg-node");
+  ok(node, "the command had a resulting output node");
+  ok(/hello world/.test(node.textContext), "the command's output is correct.");
+}
+
+function testRemoveCommands() {
+  let gcli = require("gcli/index");
+  gcli.removeCommand(tselarr);
+
+  let canon = require("gcli/canon");
+  let tselcmd = canon.getCommand("tselarr");
+  ok(tselcmd == null, "tselcmd removed from the canon");
+}
diff --git a/browser/locales/en-US/chrome/browser/gcli.properties b/browser/locales/en-US/chrome/browser/gcli.properties
new file mode 100644
--- /dev/null
+++ b/browser/locales/en-US/chrome/browser/gcli.properties
@@ -0,0 +1,118 @@
+
+canonDescNone=(No description)
+cliEvalJavascript=Enter JavaScript directly
+fieldSelectionSelect=Select a %S ...
+fieldArrayAdd=Add
+fieldArrayDel=Del
+jstypeParseScope=Scope lost
+jstypeParseMissing=Can\'t find property \'%S\'
+jstypeBeginSyntax=Syntax error
+jstypeBeginUnterm=Unterminated string literal
+typesNumberNan=Can\'t convert "%S" to a number.
+typesNumberMax=%1$S is greater that maximum allowed: %2$S.
+typesNumberMin=%1$S is smaller that minimum allowed: %2$S.
+typesSelectionNomatch=Can\'t use \'%S\'.'
+
+nodeParseSyntax=Syntax error in CSS query
+
+editDesc=Tweak a page resource
+editManual=Edit one of the resources that is part of this page (or maybe any generic web resource?)
+editResourceDesc=URL to edit
+editPretend=Pretend this is an popup editor containing
+
+stylizerDesc=Edit CSS for a node
+stylizerManual=Find the CSS rules that affect a node so we can edit them together
+stylizerNodeDesc=Node to edit (by CSS expression)
+stylizerReply=This is where we open a window to edit the styles for: %S.
+
+breakDesc=Manage breakpoints
+breakManual=Commands to list, add and remove breakpoints
+
+breaklistDesc=Display known breakpoints
+breaklistNone=No breakpoints set
+breaklistIntro=The following breakpoints are set:
+
+breakaddIfDesc=Break condition
+breakaddAdded=Added breakpoint
+breakaddDesc=Add a breakpoint
+breakaddManual=Breakpoint types supported: line, function, xhr, event
+
+breakaddlineDesc=Add a line breakpoint
+breakaddlineFileDesc=JS file
+breakaddlineLineDesc=Line number
+breakaddfuncDesc=Add a function breakpoint
+breakaddfuncFunctionDesc=Function
+breakaddxhrDesc=Add an XHR breakpoint
+breakaddeventDesc=Add an event breakpoint
+breakaddeventEventDesc=Event type
+breakaddeventNodeDesc=Node
+
+breaknextDesc=Break at next line
+breaknextReply=Breaking at next line
+
+breakdelDesc=Remove a breakpoint
+breakdelBreakidDesc=Index of breakpoint
+breakdelRemoved=Breakpoint removed
+
+stepDesc=Move the debugger on
+stepManual=When the debugger is stopped, move it to a new place
+stepInsult=The debugger is not stopped. How do you expect to start it? Duh!
+
+stepupDesc=Step out of the current function
+stepupManual=Move the debug position up one stack frame by running to the end of the current function
+
+stepinDesc=Step into the current function
+stepinManual=Move the debug position down one stack frame into the current function call
+
+stepnextDesc=Step to the next line
+stepnextManual=Move the debug position to the start of the next line
+
+steponDesc=Continue running
+steponManual=Resume the debugger running normally
+
+steptoDesc=Run to the given line
+steptoManual=Move the debug position to the start of the specified line
+steptoLineDesc=Line to run to
+
+highlightDesc=Highlight a node
+highlightManual=Examine the dimensions and essential properties of a node (by CSS query)
+highlightNodeDesc=CSS query
+highlightReply=Pretend the highlighter thing is doing its stuff now.
+
+inspectDesc=Inspect the CSS for a node
+inspectManual=Examine the detail of the CSS properties for a node
+inspectNodeDesc=CSS query
+inspectReply=Pretend the style inspector is doing its stuff now.
+
+doctorDesc=Open CSS Doctor for a node
+doctorManual=Diagnose why a CSS rule isn\'t working for an element
+doctorNodeDesc=CSS query
+doctorReply=Pretend the CSS Doctor is doing its stuff now.
+
+echoDesc=Show a message
+echoMessageDesc=Message
+
+consoleDesc=Commands to control the console
+consoleManual=Filter, clear and close the web console
+
+consoleclearDesc=Clear the console
+consoleclearReply=I\'m sorry, Dave, I can\'t let you do that
+
+consolecloseDesc=Close the console
+consolecloseReply=A closed console is like a closed mind which is like a closed book which is bad.
+
+consolefilterDesc=Filter displayed events
+consolefilterCategoryDesc=Category
+consolefilterLevelDesc=Level
+consolefilterDisplayDesc=Show|Hide
+consolefilterReply=This needs implementing
+
+scratchpadDesc=Open a scratchpad
+scratchpadManual=Scratchpad allows editing JavaScript in a smalltalk-like environment
+scratchpadFileDesc=Initial file
+scratchpadScriptDesc=Initial script
+scratchpadChromeDesc=Chrome privilages
+scratchpadOnesource=Only one of --file and --script should be used
+scratchpadFilepretend=Pretend this is a scratchpad with the contents of %S
+scratchpadScriptpretend=Pretend this is a scratchpad containing this text
+scratchpadEmptypretend=Pretend this is an empty scratchpad
diff --git a/browser/locales/jar.mn b/browser/locales/jar.mn
--- a/browser/locales/jar.mn
+++ b/browser/locales/jar.mn
@@ -14,6 +14,7 @@
 *   locale/browser/browser.dtd                     (%chrome/browser/browser.dtd)
     locale/browser/baseMenuOverlay.dtd             (%chrome/browser/baseMenuOverlay.dtd)
     locale/browser/browser.properties              (%chrome/browser/browser.properties)
+    locale/browser/gcli.properties                 (%chrome/browser/gcli.properties)
     locale/browser/styleinspector.properties       (%chrome/browser/styleinspector.properties)
     locale/browser/styleinspector.dtd              (%chrome/browser/styleinspector.dtd)
     locale/browser/scratchpad.properties           (%chrome/browser/scratchpad.properties)
diff --git a/toolkit/locales/en-US/chrome/global/headsUpDisplay.properties b/toolkit/locales/en-US/chrome/global/headsUpDisplay.properties
--- a/toolkit/locales/en-US/chrome/global/headsUpDisplay.properties
+++ b/toolkit/locales/en-US/chrome/global/headsUpDisplay.properties
@@ -172,3 +172,17 @@ stacktrace.anonymousFunction=<anonymous>
 # to console.trace(). The stack trace of JavaScript function calls is displayed.
 # In this minimal message we only show the last call.
 stacktrace.outputMessage=Stack trace from %S, function %S, line %S.
+
+# LOCALIZATION NOTE (termTypeCommand):
+# This string is used in the Web Console to select the type of input, there are
+# 2 basic options: JavaScript (i.e. enter instructions using EcmaScript /
+# JavaScript) or Command (which is more like a traditional command line). This
+# is the label for the command input type.
+termTypeCommand=Command
+
+# LOCALIZATION NOTE (termTypeJavascript):
+# This string is used in the Web Console to select the type of input, there are
+# 2 basic options: JavaScript (i.e. enter instructions using EcmaScript /
+# JavaScript) or Command (which is more like a traditional command line). This
+# is the label for the JavaScript input type.
+termTypeJavascript=JavaScript
diff --git a/toolkit/themes/gnomestripe/global/webConsole.css b/toolkit/themes/gnomestripe/global/webConsole.css
--- a/toolkit/themes/gnomestripe/global/webConsole.css
+++ b/toolkit/themes/gnomestripe/global/webConsole.css
@@ -135,10 +135,19 @@
 
 .hud-output-node,
 .jsterm-input-node,
-.jsterm-complete-node {
+.jsterm-complete-node,
+.gcliterm-input-node,
+.gcliterm-complete-node {
   font: 12px "DejaVu Sans Mono", monospace;
 }
 
+.jsterm-input-node,
+.jsterm-complete-node,
+.gcliterm-input-node,
+.gcliterm-complete-node {
+  background-color: transparent;
+}
+
 .hud-output-node {
   -moz-appearance: none;
   border-bottom: 1px solid ThreeDShadow;
@@ -280,13 +289,16 @@
 }
 
 .jsterm-input-node,
-.jsterm-complete-node {
+.jsterm-complete-node,
+.gcliterm-input-node,
+.gcliterm-complete-node {
   border: none;
   padding: 0 0 0 16px;
   -moz-appearance: none;
 }
 
-.jsterm-input-node {
+.jsterm-input-node,
+.gcliterm-input-node {
   width: 98%;
   background: url("chrome://global/skin/icons/commandline.png") 4px 3px no-repeat;
 }
@@ -314,3 +326,25 @@
   width: 100%;
   background-color: white;
 }
+
+.gcliterm-complete-node {
+  color: #F00;
+  margin: 4px;
+}
+
+.gcliterm-complete-node span.gcliINCOMPLETE {
+  color: #DDD;
+  border-bottom: 2px dotted #999;
+}
+
+.gcliterm-complete-node span.gcliERROR {
+  color: #DDD; border-bottom: 2px dotted #F00;
+}
+
+.gcliterm-complete-node span.gcliPrompt {
+  color: #66F; font-weight: bold;
+}
+
+.gcliterm-complete-node span.gcliCompl {
+  color: #999;
+}
diff --git a/toolkit/themes/pinstripe/global/webConsole.css b/toolkit/themes/pinstripe/global/webConsole.css
--- a/toolkit/themes/pinstripe/global/webConsole.css
+++ b/toolkit/themes/pinstripe/global/webConsole.css
@@ -138,10 +138,19 @@
 
 .hud-output-node,
 .jsterm-input-node,
-.jsterm-complete-node {
+.jsterm-complete-node,
+.gcliterm-input-node,
+.gcliterm-complete-node {
   font: 11px Menlo, Monaco, monospace;
 }
 
+.jsterm-input-node,
+.jsterm-complete-node,
+.gcliterm-input-node,
+.gcliterm-complete-node {
+  background-color: transparent;
+}
+
 .hud-output-node {
   -moz-appearance: none;
   border-bottom: 1px solid ThreeDShadow;
@@ -353,18 +362,24 @@
 }
 
 .jsterm-input-node,
-.jsterm-complete-node {
+.jsterm-complete-node,
+.gcliterm-input-node,
+.gcliterm-complete-node {
   border: none;
   padding: 0 0 0 16px;
   -moz-appearance: none;
 }
 
-.jsterm-input-node {
+.jsterm-input-node,
+.gcliterm-input-node {
   background: url("chrome://global/skin/icons/commandline.png") 4px 2px no-repeat;
 }
 
 :-moz-any(.jsterm-input-node,
-          .jsterm-complete-node) > .textbox-input-box > .textbox-textarea {
+          .jsterm-complete-node,
+          .gcliterm-input-node,
+          .gcliterm-complete-node
+          ) > .textbox-input-box > .textbox-textarea {
   overflow-x: hidden;
 }
 
@@ -398,3 +413,25 @@
   width: 100%;
   background-color: white;
 }
+
+.gcliterm-complete-node {
+  color: #F00;
+  margin: 4px;
+}
+
+.gcliterm-complete-node span.gcliINCOMPLETE {
+  color: #DDD;
+  border-bottom: 2px dotted #999;
+}
+
+.gcliterm-complete-node span.gcliERROR {
+  color: #DDD; border-bottom: 2px dotted #F00;
+}
+
+.gcliterm-complete-node span.gcliPrompt {
+  color: #66F; font-weight: bold;
+}
+
+.gcliterm-complete-node span.gcliCompl {
+  color: #999;
+}
diff --git a/toolkit/themes/winstripe/global/webConsole.css b/toolkit/themes/winstripe/global/webConsole.css
--- a/toolkit/themes/winstripe/global/webConsole.css
+++ b/toolkit/themes/winstripe/global/webConsole.css
@@ -134,10 +134,53 @@
 
 .hud-output-node,
 .jsterm-input-node,
-.jsterm-complete-node {
+.jsterm-complete-node,
+.gcliterm-input-node,
+.gcliterm-complete-node {
   font: 12px Consolas, Lucida Console, monospace;
 }
 
+.usegcli .jsterm-input-node,
+.usegcli .jsterm-complete-node,
+.gcliterm-input-node,
+.gcliterm-complete-node {
+  border: none;
+  -moz-appearance: none;
+  height: 100%;
+  vertical-align: middle;
+  background-color: transparent;
+  font: 12px Consolas, Lucida Console, monospace;
+  padding: 2px 0 0 16px;
+}
+
+.gcliterm-complete-node {
+  padding: 4px 4px 2px 21px;
+}
+
+.gcliterm-complete-node span.gcliVALID {
+  color: #FFF;
+  border-bottom: none;
+}
+
+.gcliterm-complete-node span.gcliINCOMPLETE {
+  color: #DDD;
+  border-bottom: 1px dotted #999;
+}
+
+.gcliterm-complete-node span.gcliERROR {
+  color: #DDD;
+  border-bottom: 1px dotted #F00;
+}
+
+.gcliterm-complete-node span.gcliPrompt {
+  color: #66F;
+  font-weight: bold;
+}
+
+.gcliterm-complete-node span.gcliCompl {
+  color: #999;
+}
+
 .hud-output-node {
   -moz-appearance: none;
   border-bottom: 1px solid ThreeDShadow;
@@ -296,7 +339,18 @@
   -moz-appearance: none;
 }
 
-.jsterm-input-node {
+.gcliterm-stack-node {
+  background: url("chrome://global/skin/icons/commandline.png") 4px center no-repeat;
+  width: 100%;
+}
+
+.gcliterm-input-node,
+.gcliterm-complete-node {
+  background: transparent;
+}
+
+.jsterm-input-node,
+.jsterm-complete-node {
   background: url("chrome://global/skin/icons/commandline.png") 4px 3px no-repeat;
 }
 
@@ -331,3 +385,7 @@
   width: 100%;
   background-color: white;
 }
+
+.gcliCmdHelpRight {
+  text-align: right;
+}
